/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "rpc.h"
#include <string.h>
#include <strings.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <ncurses.h>
#include <sys/types.h>

void
program_write_1(char *host)
{
	CLIENT *clnt;
	int  *result_1;
	message  msg;
	chat_block  *chat;
	int  my_revision = 0;

#ifndef	DEBUG
	clnt = clnt_create (host, PROGRAM_WRITE, VERSION_WRITE, "udp");
	if (clnt == NULL) {
		clnt_pcreateerror (host);
		exit (1);
	}
#endif	/* DEBUG */
	printf("Enter your username: ");
	fgets(msg.name, 10, stdin);
	msg.name[ strlen(msg.name) - 1 ] = 0;

	int flags = fcntl(0, F_GETFL, 0);
	fcntl(0, F_SETFL, flags | O_NONBLOCK);

	printf("Welcome %s!\n", msg.name);

	/*initscr();

	cbreak();			  // Immediate key input
	nonl();				  // Get return key
	timeout(0);			  // Non-blocking input
	keypad(stdscr, 1);	  // Fix keypad
	noecho();			  // No automatic printing
	curs_set(0);		  // Hide real cursor
	intrflush(stdscr, 0); // Avoid potential graphical issues
	leaveok(stdscr, 1);	  // Don't care where cursor is left
	
	// FORK
	 (fork() == 0){

	}else{

	}*/

	// Set up windows
	initscr();
	getmaxyx(stdscr, maxy, maxx);

	top = newwin(maxy / 2, maxx, 0, 0);
	bottom = newwin(maxy / 2, maxx, maxy / 2, 0);

	scrollok(top, TRUE);
	scrollok(bottom, TRUE);
	box(top, '|', '=');
	box(bottom, '|', '-');

	wsetscrreg(top, 1, maxy / 2 - 2);
	wsetscrreg(bottom, 1, maxy / 2 - 2);

	// Set up threads
	pthread_t threads[2];
	void *status;
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);

	// Spawn the listen/receive deamons
	pthread_create(&threads[0], &attr, sendmessage, (void *)name);
	pthread_create(&threads[1], &attr, listener, NULL);

	// Keep alive until finish condition is done
	while (!done);

	mvprintw(0, 0, "\n\n%s -->", msg.name);
	refresh();

	while(1)
	{
		//Get chat
		do
		{
			if(NULL != chat->block)
				bzero(chat->block, 269);

			chat = getchat_1(&my_revision, clnt);
			if (chat->block[0] != 0){
				mvprintw(2,0,"%s", chat->block);
				refresh();
			}


			//printf("Reading\n");
			my_revision = chat->revision_number;
			
			if (my_revision >= chat->total_revisions)
			{
				//printf("No new messages!\n");
			}

			if (chat == (chat_block *)NULL)
			{
				clnt_perror(clnt, "call failed");
			}

			
		} while (my_revision < chat->total_revisions);
		

		//Read input
		while (read(0, msg.message, sizeof(msg.message)) > 0)
		{
			
			msg.message[strlen(msg.message) - 1] = 0;
			if (strcmp(msg.message, "exit") == 0)
			{
				break;
			}
			result_1 = write_1(&msg, clnt);

			bzero(msg.message, 269);
			//printf("\nmessage sent!\n");
			my_revision += *result_1;

			if (result_1 == (int *)NULL)
			{
				clnt_perror(clnt, "call failed");
			}
		}
		fflush(stdin);	
		if (strcmp(msg.message, "quit") == 0) break;

		//Sleep
		sleep(1);		
	}

	endwin();
	
#ifndef	DEBUG
	clnt_destroy (clnt);
#endif	 /* DEBUG */
}




void *get_in_addr(struct sockaddr *sa)
{
	if (sa->sa_family == AF_INET)
	{
		return &(((struct sockaddr_in *)sa)->sin_addr);
	}

	return &(((struct sockaddr_in6 *)sa)->sin6_addr);
}

// Send message from keyboard to server and update screen
void *sendmessage(void *name)
{

	char str[80];
	char msg[100];
	int bufsize = maxx - 4;
	char *buffer = malloc(bufsize);

	while (1)
	{
		bzero(str, 80);
		bzero(msg, 100);
		bzero(buffer, bufsize);
		wrefresh(top);
		wrefresh(bottom);

		// Get user's message
		mvwgetstr(bottom, input, 2, str);

		// Build the message: "name: message"
		strcpy(msg, name);
		strncat(msg, ": \0", 100 - strlen(str));
		strncat(msg, str, 100 - strlen(str));

		// Check for quiting
		if (strcmp(str, "exit") == 0)
		{

			done = 1;

			// Clean up
			endwin();
			pthread_mutex_destroy(&mutexsum);
			pthread_exit(NULL);
			close(sockfd);
		}

		// Send message to server
		write(sockfd, msg, strlen(msg));

		// write it in chat window (top)
		mvwprintw(top, line, 2, msg);

		// scroll the top if the line number exceed height
		pthread_mutex_lock(&mutexsum);

		if (line != maxy / 2 - 2)
			line++;
		else
			scroll(top);

		// scroll the bottom if the line number exceed height
		if (input != maxy / 2 - 2)
			input++;
		else
			scroll(bottom);

		pthread_mutex_unlock(&mutexsum);
	}
}

// Listen for messages and display them
void *listener()
{
	char str[80];
	int bufsize = maxx - 4;
	char *buffer = malloc(bufsize);

	while (1)
	{
		bzero(buffer, bufsize);
		wrefresh(top);
		wrefresh(bottom);

		//Receive message from server
		read(sockfd, buffer, bufsize);

		//Print on own terminal
		mvwprintw(top, line, 3, buffer);

		// scroll the top if the line number exceed height
		pthread_mutex_lock(&mutexsum);
		if (line != maxy / 2 - 2)
			line++;
		else
			scroll(top);
		pthread_mutex_unlock(&mutexsum);
	}
}

int
main (int argc, char *argv[])
{
	char *host;

	if (argc < 2) {
		printf ("usage: %s server_host\n", argv[0]);
		exit (1);
	}
	host = argv[1];
	program_write_1 (host);
exit (0);
}
